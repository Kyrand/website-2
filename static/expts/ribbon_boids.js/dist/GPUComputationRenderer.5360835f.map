{"version":3,"sources":["js/GPUComputationRenderer.js"],"names":["GPUComputationRenderer","sizeX","sizeY","renderer","variables","currentTextureIndex","scene","THREE","Scene","camera","Camera","position","z","passThruUniforms","texture","value","passThruShader","createShaderMaterial","getPassThroughFragmentShader","mesh","Mesh","PlaneBufferGeometry","add","addVariable","variableName","computeFragmentShader","initialValueTexture","material","variable","name","dependencies","renderTargets","wrapS","wrapT","minFilter","NearestFilter","magFilter","push","setVariableDependencies","init","extensions","get","capabilities","maxVertexTextures","i","length","createRenderTarget","renderTexture","uniforms","d","depVar","found","j","fragmentShader","compute","nextTextureIndex","il","dl","doRenderTarget","getCurrentRenderTarget","getAlternateRenderTarget","addResolutionDefine","materialShader","defines","resolution","toFixed","ShaderMaterial","vertexShader","getPassThroughVertexShader","sizeXTexture","sizeYTexture","ClampToEdgeWrapping","renderTarget","WebGLRenderTarget","format","RGBAFormat","type","test","navigator","userAgent","HalfFloatType","FloatType","stencilBuffer","depthBuffer","createTexture","a","Float32Array","DataTexture","needsUpdate","input","output","render"],"mappings":"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","file":"GPUComputationRenderer.5360835f.map","sourceRoot":"..","sourcesContent":["/**\n * @author yomboprime https://github.com/yomboprime\n *\n * GPUComputationRenderer, based on SimulationRenderer by zz85\n *\n * The GPUComputationRenderer uses the concept of variables. These variables are RGBA float textures that hold 4 floats\n * for each compute element (texel)\n *\n * Each variable has a fragment shader that defines the computation made to obtain the variable in question.\n * You can use as many variables you need, and make dependencies so you can use textures of other variables in the shader\n * (the sampler uniforms are added automatically) Most of the variables will need themselves as dependency.\n *\n * The renderer has actually two render targets per variable, to make ping-pong. Textures from the current frame are used\n * as inputs to render the textures of the next frame.\n *\n * The render targets of the variables can be used as input textures for your visualization shaders.\n *\n * Variable names should be valid identifiers and should not collide with THREE GLSL used identifiers.\n * a common approach could be to use 'texture' prefixing the variable name; i.e texturePosition, textureVelocity...\n *\n * The size of the computation (sizeX * sizeY) is defined as 'resolution' automatically in the shader. For example:\n * #DEFINE resolution vec2( 1024.0, 1024.0 )\n *\n * -------------\n *\n * Basic use:\n *\n * // Initialization...\n *\n * // Create computation renderer\n * var gpuCompute = new GPUComputationRenderer( 1024, 1024, renderer );\n *\n * // Create initial state float textures\n * var pos0 = gpuCompute.createTexture();\n * var vel0 = gpuCompute.createTexture();\n * // and fill in here the texture data...\n *\n * // Add texture variables\n * var velVar = gpuCompute.addVariable( \"textureVelocity\", fragmentShaderVel, pos0 );\n * var posVar = gpuCompute.addVariable( \"texturePosition\", fragmentShaderPos, vel0 );\n *\n * // Add variable dependencies\n * gpuCompute.setVariableDependencies( velVar, [ velVar, posVar ] );\n * gpuCompute.setVariableDependencies( posVar, [ velVar, posVar ] );\n *\n * // Add custom uniforms\n * velVar.material.uniforms.time = { value: 0.0 };\n *\n * // Check for completeness\n * var error = gpuCompute.init();\n * if ( error !== null ) {\n *\t\tconsole.error( error );\n  * }\n *\n *\n * // In each frame...\n *\n * // Compute!\n * gpuCompute.compute();\n *\n * // Update texture uniforms in your visualization materials with the gpu renderer output\n * myMaterial.uniforms.myTexture.value = gpuCompute.getCurrentRenderTarget( posVar ).texture;\n *\n * // Do your rendering\n * renderer.render( myScene, myCamera );\n *\n * -------------\n *\n * Also, you can use utility functions to create ShaderMaterial and perform computations (rendering between textures)\n * Note that the shaders can have multiple input textures.\n *\n * var myFilter1 = gpuCompute.createShaderMaterial( myFilterFragmentShader1, { theTexture: { value: null } } );\n * var myFilter2 = gpuCompute.createShaderMaterial( myFilterFragmentShader2, { theTexture: { value: null } } );\n *\n * var inputTexture = gpuCompute.createTexture();\n *\n * // Fill in here inputTexture...\n *\n * myFilter1.uniforms.theTexture.value = inputTexture;\n *\n * var myRenderTarget = gpuCompute.createRenderTarget();\n * myFilter2.uniforms.theTexture.value = myRenderTarget.texture;\n *\n * var outputRenderTarget = gpuCompute.createRenderTarget();\n *\n * // Now use the output texture where you want:\n * myMaterial.uniforms.map.value = outputRenderTarget.texture;\n *\n * // And compute each frame, before rendering to screen:\n * gpuCompute.doRenderTarget( myFilter1, myRenderTarget );\n * gpuCompute.doRenderTarget( myFilter2, outputRenderTarget );\n * \n *\n *\n * @param {int} sizeX Computation problem size is always 2d: sizeX * sizeY elements.\n * @param {int} sizeY Computation problem size is always 2d: sizeX * sizeY elements.\n * @param {WebGLRenderer} renderer The renderer\n  */\n\nfunction GPUComputationRenderer( sizeX, sizeY, renderer ) {\n\n\tthis.variables = [];\n\n\tthis.currentTextureIndex = 0;\n\n\tvar scene = new THREE.Scene();\n\n\tvar camera = new THREE.Camera();\n\tcamera.position.z = 1;\n\n\tvar passThruUniforms = {\n\t\ttexture: { value: null }\n\t};\n\n\tvar passThruShader = createShaderMaterial( getPassThroughFragmentShader(), passThruUniforms );\n\n\tvar mesh = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), passThruShader );\n\tscene.add( mesh );\n\n\n\tthis.addVariable = function( variableName, computeFragmentShader, initialValueTexture ) {\n\n\t\tvar material = this.createShaderMaterial( computeFragmentShader );\n\n\t\tvar variable = {\n\t\t\tname: variableName,\n\t\t\tinitialValueTexture: initialValueTexture,\n\t\t\tmaterial: material,\n\t\t\tdependencies: null,\n\t\t\trenderTargets: [],\n\t\t\twrapS: null,\n\t\t\twrapT: null,\n\t\t\tminFilter: THREE.NearestFilter,\n\t\t\tmagFilter: THREE.NearestFilter\n\t\t};\n\n\t\tthis.variables.push( variable );\n\n\t\treturn variable;\n\t\t\n\t};\n\n\tthis.setVariableDependencies = function( variable, dependencies ) {\n\n\t\tvariable.dependencies = dependencies;\n\n\t};\n\n\tthis.init = function() {\n\n\t\tif ( ! renderer.extensions.get( \"OES_texture_float\" ) ) {\n\n\t\t\treturn \"No OES_texture_float support for float textures.\";\n\n\t\t}\n\n\t\tif ( renderer.capabilities.maxVertexTextures === 0 ) {\n\n\t\t\treturn \"No support for vertex shader textures.\";\n\n\t\t}\n\n\t\tfor ( var i = 0; i < this.variables.length; i++ ) {\n\n\t\t\tvar variable = this.variables[ i ];\n\n\t\t\t// Creates rendertargets and initialize them with input texture\n\t\t\tvariable.renderTargets[ 0 ] = this.createRenderTarget( sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter );\n\t\t\tvariable.renderTargets[ 1 ] = this.createRenderTarget( sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter );\n\t\t\tthis.renderTexture( variable.initialValueTexture, variable.renderTargets[ 0 ] );\n\t\t\tthis.renderTexture( variable.initialValueTexture, variable.renderTargets[ 1 ] );\n\n\t\t\t// Adds dependencies uniforms to the ShaderMaterial\n\t\t\tvar material = variable.material;\n\t\t\tvar uniforms = material.uniforms;\n\t\t\tif ( variable.dependencies !== null ) {\n\n\t\t\t\tfor ( var d = 0; d < variable.dependencies.length; d++ ) {\n\n\t\t\t\t\tvar depVar = variable.dependencies[ d ];\n\n\t\t\t\t\tif ( depVar.name !== variable.name ) {\n\n\t\t\t\t\t\t// Checks if variable exists\n\t\t\t\t\t\tvar found = false;\n\t\t\t\t\t\tfor ( var j = 0; j < this.variables.length; j++ ) {\n\n\t\t\t\t\t\t\tif ( depVar.name === this.variables[ j ].name ) {\n\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( ! found ) {\n\t\t\t\t\t\t\treturn \"Variable dependency not found. Variable=\" + variable.name + \", dependency=\" + depVar.name;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tuniforms[ depVar.name ] = { value: null };\n\n\t\t\t\t\tmaterial.fragmentShader = \"\\nuniform sampler2D \" + depVar.name + \";\\n\" + material.fragmentShader;\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.currentTextureIndex = 0;\n\n\t\treturn null;\n\n\t};\n\n\tthis.compute = function() {\n\n\t\tvar currentTextureIndex = this.currentTextureIndex;\n\t\tvar nextTextureIndex = this.currentTextureIndex === 0 ? 1 : 0;\n\n\t\tfor ( var i = 0, il = this.variables.length; i < il; i++ ) {\n\n\t\t\tvar variable = this.variables[ i ];\n\n\t\t\t// Sets texture dependencies uniforms\n\t\t\tif ( variable.dependencies !== null ) {\n\n\t\t\t\tvar uniforms = variable.material.uniforms;\n\t\t\t\tfor ( var d = 0, dl = variable.dependencies.length; d < dl; d++ ) {\n\n\t\t\t\t\tvar depVar = variable.dependencies[ d ];\n\n\t\t\t\t\tuniforms[ depVar.name ].value = depVar.renderTargets[ currentTextureIndex ].texture;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Performs the computation for this variable\n\t\t\tthis.doRenderTarget( variable.material, variable.renderTargets[ nextTextureIndex ] );\n\n\t\t}\n\n\t\tthis.currentTextureIndex = nextTextureIndex;\n\t};\n\n\tthis.getCurrentRenderTarget = function( variable ) {\n\n\t\treturn variable.renderTargets[ this.currentTextureIndex ];\n\n\t};\n\n\tthis.getAlternateRenderTarget = function( variable ) {\n\n\t\treturn variable.renderTargets[ this.currentTextureIndex === 0 ? 1 : 0 ];\n\n\t};\n\n\tfunction addResolutionDefine( materialShader ) {\n\n\t\tmaterialShader.defines.resolution = 'vec2( ' + sizeX.toFixed( 1 ) + ', ' + sizeY.toFixed( 1 ) + \" )\";\n\n\t}\n\tthis.addResolutionDefine = addResolutionDefine;\n\n\n\t// The following functions can be used to compute things manually\n\n\tfunction createShaderMaterial( computeFragmentShader, uniforms ) {\n\n\t\tuniforms = uniforms || {};\n\n\t\tvar material = new THREE.ShaderMaterial( {\n\t\t\tuniforms: uniforms,\n\t\t\tvertexShader: getPassThroughVertexShader(),\n\t\t\tfragmentShader: computeFragmentShader\n\t\t} );\n\n\t\taddResolutionDefine( material );\n\n\t\treturn material;\n\t}\n\tthis.createShaderMaterial = createShaderMaterial;\n\n\tthis.createRenderTarget = function( sizeXTexture, sizeYTexture, wrapS, wrapT, minFilter, magFilter ) {\n\n\t\tsizeXTexture = sizeXTexture || sizeX;\n\t\tsizeYTexture = sizeYTexture || sizeY;\n\n\t\twrapS = wrapS || THREE.ClampToEdgeWrapping;\n\t\twrapT = wrapT || THREE.ClampToEdgeWrapping;\n\n\t\tminFilter = minFilter || THREE.NearestFilter;\n\t\tmagFilter = magFilter || THREE.NearestFilter;\n\n\t\tvar renderTarget = new THREE.WebGLRenderTarget( sizeXTexture, sizeYTexture, {\n\t\t\twrapS: wrapS,\n\t\t\twrapT: wrapT,\n\t\t\tminFilter: minFilter,\n\t\t\tmagFilter: magFilter,\n\t\t\tformat: THREE.RGBAFormat,\n\t\t\ttype: ( /(iPad|iPhone|iPod)/g.test( navigator.userAgent ) ) ? THREE.HalfFloatType : THREE.FloatType,\n\t\t\tstencilBuffer: false,\n\t\t\tdepthBuffer: false\n\t\t} );\n\n\t\treturn renderTarget;\n\n\t};\n\n\tthis.createTexture = function() {\n\n\t\tvar a = new Float32Array( sizeX * sizeY * 4 );\n\t\tvar texture = new THREE.DataTexture( a, sizeX, sizeY, THREE.RGBAFormat, THREE.FloatType );\n\t\ttexture.needsUpdate = true;\n\n\t\treturn texture;\n\n\t};\n\n\n\tthis.renderTexture = function( input, output ) {\n\n\t\t// Takes a texture, and render out in rendertarget\n\t\t// input = Texture\n\t\t// output = RenderTarget\n\n\t\tpassThruUniforms.texture.value = input;\n\n\t\tthis.doRenderTarget( passThruShader, output);\n\n\t\tpassThruUniforms.texture.value = null;\n\n\t};\n\n\tthis.doRenderTarget = function( material, output ) {\n\n\t\tmesh.material = material;\n\t\trenderer.render( scene, camera, output );\n\t\tmesh.material = passThruShader;\n\n\t};\n\n\t// Shaders\n\n\tfunction getPassThroughVertexShader() {\n\n\t\treturn\t\"void main()\t{\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"\tgl_Position = vec4( position, 1.0 );\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"}\\n\";\n\n\t}\n\n\tfunction getPassThroughFragmentShader() {\n\n\t\treturn\t\"uniform sampler2D texture;\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"void main() {\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"\tvec2 uv = gl_FragCoord.xy / resolution.xy;\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"\tgl_FragColor = texture2D( texture, uv );\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"}\\n\";\n\n\t}\n\n}\n"]}